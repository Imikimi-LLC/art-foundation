{compactFlatten} = require '../standard_lib/array_compact_flatten'
{upperCamelCase} = require '../standard_lib/string_case'

mergeIntoBasic = (into, source) ->
  into[k] = v for k, v of source
  into

module.exports = class ObjectTreeFactory
  deepArgsProcessing = (array, children) ->
    for el in array when el
      if el.constructor == Array
        deepArgsProcessing el, children
      else children.push el
    null

  ###
  IN:
    nodeFactory: ->
      IN:
        props:    plain object mapping props to prop-values
        children: flat, compacted array of children nodes
      OUT:
        node

  OUT: objectTreeFactory = ->
    IN:
      Arguments are compacted and flattened
      The resulting list of arguments can be any combination of:
        plainObjects for props (merged in the order they appear)
        other objects which become the 'children'

    OUT:
      object-tree-node generated by the nodeFactory
  ###
  preprocessElementBasic = (a) -> a
  @createObjectTreeFactory = (
    options
    nodeFactory
  ) =>
    unless nodeFactory
      nodeFactory = options
      options = {}

    {mergePropsInto, inspectedName, preprocessElement} = options
    mergePropsInto ||= mergeIntoBasic
    preprocessElement ||= preprocessElementBasic

    ret = ->
      oneProps = null
      props = null
      children = []

      for el in arguments when el = preprocessElement el
        switch el.constructor
          when Object
            if oneProps
              props = {}
              mergePropsInto props, oneProps
              oneProps = null
            if props
              mergePropsInto props, el
            else
              oneProps = el

          when Array
            deepArgsProcessing el, children
          else children.push el

      props ||= oneProps || {}
      nodeFactory props, children

    # show nice output when inspected
    ret.inspect = -> "<#{inspectedName || 'ObjectTreeFactory'}>"
    ret

  ###
  IN:
    list: a string or abitrary structure of arrays, nulls and strings
      each string is split into tokens and each token is used as the nodeTypeName to create a Tree-factory
    nodeFactory: (nodeTypeName, props, children) -> node
      IN:
        nodeTypeName: node-type name
        props:    plain object mapping props to prop-values
        children: flat, compacted array of children nodes
      OUT:
        node
  OUT:
    map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory

  TODO:
    PERFORMANCE TEST:
      createObjectTreeFactoriesFromFactories
      vs
      createObjectTreeFactoriesFromFactoryFactories

      The latter is probably faster. It is also more powerful and generally cleaner.
  ###
  @createObjectTreeFactories: (options, list, nodeFactory) =>
    unless nodeFactory
      [list, nodeFactory] = [options, list]
      options = {}

    if nodeFactory.length == 1
      @_createObjectTreeFactoriesFromFactoryFactories options, list, nodeFactory
    else
      @_createObjectTreeFactoriesFromFactories options, list, nodeFactory

  @_createObjectTreeFactoriesFromFactories: (options, list, nodeFactory) =>
    suffix = options.suffix || ''

    out = {}
    for nodeTypeName in compactFlattenObjectTreeNodeNames list
      do (nodeTypeName) =>
        options.inspectedName = nodeTypeName
        out[upperCamelCase(nodeTypeName) + suffix] = @createObjectTreeFactory options,
          (props, children) -> nodeFactory nodeTypeName, props, children
    out

  nodeNameRegexp = /[a-z0-9_]+/ig
  @_compactFlattenObjectTreeNodeNames: compactFlattenObjectTreeNodeNames = (list) ->
    return list.match nodeNameRegexp if typeof list == "string"

    out = []
    for str in compactFlatten list
      out = out.concat str.match nodeNameRegexp
    out

  @_createObjectTreeFactoriesFromFactoryFactories: (options, list, nodeFactoryFactory) =>
    suffix = options.suffix || ''

    out = {}
    for nodeTypeName in compactFlattenObjectTreeNodeNames list
      nodeFactory = nodeFactoryFactory nodeTypeName
      name = upperCamelCase(nodeTypeName) + suffix
      options.inspectedName = name
      out[name] = @createObjectTreeFactory options, nodeFactory
    out

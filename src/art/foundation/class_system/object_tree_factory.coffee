{compactFlatten} = require '../standard_lib/array_compact_flatten'
{upperCamelCase} = require '../standard_lib/string_case'

mergeIntoBasic = (into, source) ->
  into[k] = v for k, v of source
  into

module.exports = class ObjectTreeFactory
  deepArgsProcessing = (array, children) ->
    for el in array when el
      if el.constructor == Array
        deepArgsProcessing el, children
      else children.push el
    null

  ###
  IN:
    nodeFactory: ->
      IN:
        props:    plain object mapping props to prop-values
        children: flat, compacted array of children nodes
      OUT:
        node

  OUT: objectTreeFactory = ->
    IN:
      Arguments are compacted and flattened
      The resulting list of arguments can be any combination of:
        plainObjects for props (merged in the order they appear)
        other objects which become the 'children'

    OUT:
      object-tree-node generated by the nodeFactory
  ###
  @createObjectTreeFactory = (nodeFactory, customMergePropsInto = mergeIntoBasic, inspectedName) =>
    ret = ->
      oneProps = null
      props = null
      children = []

      for el in arguments when el
        switch el.constructor
          when Object
            if oneProps
              props = {}
              customMergePropsInto props, oneProps
              oneProps = null
            if props
              customMergePropsInto props, el
            else
              oneProps = el

          when Array
            deepArgsProcessing el, children
          else children.push el

      props ||= oneProps || {}
      nodeFactory props, children

    # show nice output when inspected
    ret.inspect = -> "<#{inspectedName || 'ObjectTreeFactory'}>"
    ret

  ###
  IN:
    list: a string or abitrary structure of arrays, nulls and strings
      each string is split into tokens and each token is used as the nodeTypeName to create a Tree-factory
    nodeFactory: (nodeTypeName, props, children) -> node
      IN:
        nodeTypeName: node-type name
        props:    plain object mapping props to prop-values
        children: flat, compacted array of children nodes
      OUT:
        node
  OUT:
    map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory

  TODO:
    PERFORMANCE TEST:
      createObjectTreeFactoriesFromFactories
      vs
      createObjectTreeFactoriesFromFactoryFactories

      The latter is probably faster. It is also more powerful and generally cleaner.
  ###
  @createObjectTreeFactories: (list, nodeFactory, suffix = '', customMergePropsInto = mergeIntoBasic) =>
    if nodeFactory.length == 1
      @createObjectTreeFactoriesFromFactoryFactories list, nodeFactory, suffix, customMergePropsInto
    else
      @createObjectTreeFactoriesFromFactories list, nodeFactory, suffix, customMergePropsInto

  @createObjectTreeFactoriesFromFactories: (list, nodeFactory, suffix = '', customMergePropsInto = mergeIntoBasic) =>
    out = {}
    for nodeTypeName in compactFlattenObjectTreeNodeNames list
      do (nodeTypeName) =>
        out[upperCamelCase(nodeTypeName) + suffix] = @createObjectTreeFactory (props, children) ->
          nodeFactory nodeTypeName, props, children
        , customMergePropsInto, nodeTypeName
    out

  nodeNameRegexp = /[a-z0-9_]+/ig
  @compactFlattenObjectTreeNodeNames: compactFlattenObjectTreeNodeNames = (list) ->
    return list.match nodeNameRegexp if typeof list == "string"

    out = []
    for str in compactFlatten list
      out = out.concat str.match nodeNameRegexp
    out

  @createObjectTreeFactoriesFromFactoryFactories: (list, nodeFactoryFactory, suffix = '', customMergePropsInto = mergeIntoBasic) =>
    out = {}
    for nodeTypeName in compactFlattenObjectTreeNodeNames list
      nodeFactory = nodeFactoryFactory nodeTypeName
      name = upperCamelCase(nodeTypeName) + suffix
      out[name] = @createObjectTreeFactory nodeFactory, customMergePropsInto, name
    out

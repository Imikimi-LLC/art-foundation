{compactFlatten} = require '../standard_lib/array_compact_flatten'
{upperCamelCase} = require '../standard_lib/string_case'

mergeIntoBasic = (into, source) ->
  into[k] = v for k, v of source
  into

module.exports = class ObjectTreeFactory
  deepArgsProcessing = (array, children) ->
    for el in array when el
      if el.constructor == Array
        deepArgsProcessing el, children
      else children.push el
    null

  ###
  IN:
    nodeFactory: ->
      IN:
        props:    plain object mapping props to prop-values
        children: flat, compacted array of children nodes
      OUT:
        node

  OUT: objectTreeFactory = ->
    IN:
      Arguments are compacted and flattened
      The resulting list of arguments can be any combination of:
        plainObjects for props (merged in the order they appear)
        other objects which become the 'children'

    OUT:
      object-tree-node generated by the nodeFactory
  ###
  @createObjectTreeFactory = (nodeFactory, mergePropsInto = mergeIntoBasic) =>
    ->
      oneProps = null
      props = null
      children = []

      for el in arguments when el
        switch el.constructor
          when Object
            if oneProps
              props = {}
              mergePropsInto props, oneProps
              oneProps = null
            if props
              mergePropsInto props, el
            else
              oneProps = el

          when Array
            deepArgsProcessing el, children
          else children.push el

      props ||= oneProps || {}
      nodeFactory props, children

  ###
  IN:
    list: a string or abitrary structure of arrays, nulls and strings
      each string is split into tokens and each token is used as the nodeName to create a Tree-factory
    nodeFactory: (nodeName, props, children) -> node
      IN:
        nodeName: node-type name
        props:    plain object mapping props to prop-values
        children: flat, compacted array of children nodes
      OUT:
        node
  OUT:
    map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory
  ###
  @createObjectTreeFactories: (list, nodeFactory, suffix = '', mergePropsInto = mergeIntoBasic) =>
    out = {}
    list = [list] if typeof list == "string"
    for str in compactFlatten list
      for nodeName in str.match /[a-z0-9_]+/ig
        do (nodeName) =>
          out[upperCamelCase(nodeName) + suffix] = @createObjectTreeFactory (props, children) ->
            nodeFactory nodeName, props, children
          , mergePropsInto
    out

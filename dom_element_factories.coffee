###
@license
Copyright (c) 2016 Imikimi, LLC

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
###

###
dom_element_factories.coffee

This is a stand-alone version of Art.Foundation.Browser.Dom.createDomElementFactories.

It allows for Art.React-style creation of DOM elements.

Usage:

{Div, Span, B, Em, merge} = DomElementFactories

mySharedTextStyle =
  fontSize: "16pt"
  color: "#444"
  fontFamily: "Times"

Div
  class: "foo"
  id:    "123"

  Span
    class: "dude"
    "This is some really"
    B "bold"
    "text."
    "Also, here is some"
    Em "emphasized"
    "text."

  Span
    style: mySharedTextStyle
    internalHTML: "Or you can do <b>this</b> and <em>this</em>."

  Div
    style: merge mySharedTextStyle,
      bottom:          0
      height:          "50px"
      left:            "100px"
      right:           "100px"
      position:        "fixed"
      backgroundColor: "white"
      textAlign:       "center"
    "Styles are easy, too."

###

#####################
# ARRAY: compactFlatten
#####################
arraySlice = Array.prototype.slice

isArguments = (o) ->
  o.constructor == Object &&
  (typeof o.callee is "function") &&
  (typeof o.length is "number")

isArrayOrArguments = (o) ->
  o && (o.constructor == Array || isArguments o)

doFlattenInternal = (array, keepTester, output) ->
  output ||= []
  for a in array
    if isArrayOrArguments a
      flattenIfNeeded a, keepTester, output
    else if keepTester a
      output.push a
  output

needsFlatteningOrCompacting = (array, keepTester) ->
  for a in array when isArrayOrArguments(a) || !keepTester a
    return true
  false

keepAll = -> true
flattenIfNeeded = (array, keepTester = keepAll, output)->
  if needsFlatteningOrCompacting array, keepTester
    doFlattenInternal array, keepTester, output
  else if output
    output.push v for v in array
    output
  else if array.constructor != Array
    arraySlice.call array
  else
    array

keepUnlessNullOrUndefined = (a) -> a != undefined && a != null

###
IN:
  array: an instance of Array or an array-like object (one that Array.prototype.slice can slice)
    this includes Arguments objects
  keepTester: (value) -> true/false
    IN: candidate value for the output array
    OUT: true if the candidate value should be added to the output array
    DEFAULT: (a) -> true
OUT:
  Array instance that doesn't contain any Arrays or array-like objects as direct elements
  any element that is in the original array or a sub-array-like-object was added to
  the output array if it passes the keepTester test.
###
compactFlatten = (array, keepTester = keepUnlessNullOrUndefined)->
  flattenIfNeeded array, keepTester

#####################
# OBJECTS
#####################
merge = -> mergeInto {}, arguments

mergeIntoBasic = (into, source) ->
  into[k] = v for k, v of source
  into

mergeInto = ->
  sources = compactFlatten arguments
  return null if sources.length == 0
  result = sources[0] || {}
  for i in [1...sources.length] by 1
    mergeIntoBasic result, sources[i]
  result

#####################
# STRING: isString, capitalize, upperCamelCase
#####################
isString = (obj) => typeof obj == "string"
capitalize = (str) -> str.charAt(0).toUpperCase() + str.slice 1
upperCamelCase = (str) => (capitalize word for word in str.split '_').join ""

#####################
# ObjectTreeFactory
#####################

deepArgsProcessing = (array, children) ->
  for el in array when el
    if el.constructor == Array
      deepArgsProcessing el, children
    else children.push el
  null

###
IN:
  nodeFactory: ->
    IN:
      props:    plain object mapping props to prop-values
      children: flat, compacted array of children nodes
    OUT:
      node

OUT: objectTreeFactory = ->
  IN:
    Arguments are compacted and flattened
    The resulting list of arguments can be any combination of:
      plainObjects for props (merged in the order they appear)
      other objects which become the 'children'

  OUT:
    object-tree-node generated by the nodeFactory
###
createObjectTreeFactory = (nodeFactory, mergePropsInto = mergeIntoBasic) ->
  ->
    oneProps = null
    props = null
    children = []

    for el in arguments when el
      switch el.constructor
        when Object
          if oneProps
            props = {}
            mergePropsInto props, oneProps
            oneProps = null
          if props
            mergePropsInto props, el
          else
            oneProps = el

        when Array
          deepArgsProcessing el, children
        else children.push el

    props ||= oneProps || {}
    nodeFactory props, children

###
IN:
  list: a string or abitrary structure of arrays, nulls and strings
    each string is split into tokens and each token is used as the nodeName to create a Tree-factory
  nodeFactory: (nodeName, props, children) -> node
    IN:
      nodeName: node-type name
      props:    plain object mapping props to prop-values
      children: flat, compacted array of children nodes
    OUT:
      node
OUT:
  map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory
###
createObjectTreeFactories = (list, nodeFactory, suffix = '', mergePropsInto = mergeIntoBasic) =>
  out = {}
  list = [list] if isString list
  for str in compactFlatten list
    for nodeName in str.match /[a-z0-9_]+/ig
      do (nodeName) =>
        out[upperCamelCase(nodeName) + suffix] = createObjectTreeFactory (props, children) ->
          nodeFactory nodeName, props, children
        , mergePropsInto
  out

#####################
# DomElementFactories
#####################
class DomElementFactories
  @upperCamelCase: upperCamelCase
  @compactFlatten: compactFlatten
  @mergeInto: mergeInto
  @merge: merge

  ###
  IN: any combination of arrays and strings
  OUT: All element-names found in all strings are used to generate dom-element-factory-functions
    for elements with those names.
    The output is a plain Object where they keys are the upperCamelCase version of the element-names
    passed in. The values are the element-factories.

  ###
  @createDomElementFactories: (list...) =>
    createObjectTreeFactories list, (nodeName, props, children) ->
      element = document.createElement nodeName
      for k, v of props
        switch k
          when "class" then element.className = v
          when "id" then element.id = v
          when "innerHTML" then element.innerHTML = v
          when "on"
            for eventType, eventListener of v
              element.addEventListener eventType, eventListener
          when "style"
            if isString v
              element.setAttribute k, v
            else
              {style} = element
              for styleKey, styleValue of v
                style[styleKey] = "" + styleValue

          else element.setAttribute k, v

      for child in children
        child = document.createTextNode child if isString child
        unless child instanceof Node
          message = "DomElementFactory:#{nodeName}: Child is not a string or instance of Node. Child: #{child}"
          console.error message, child
          throw new Error message
        element.appendChild child
      element
    , ''
    , (into, source) ->
      for k, v of source
        into[k] = if k == "style"
          mergeIntoBasic into[k], v
        else
          v

  @allElementNames: "
    A Abbr Acronym Address Applet Area Article Aside Audio B Base BaseFont Bdi Bdo
    Big BlockQuote Body Br Button Canvas Caption Center Cite Code Col ColGroup
    DataList Dd Del Details Dfn Dialog Dir Div Dl Dt Em Embed FieldSet FigCaption
    Figure Font Footer Form Frame FrameSet H1 Head Header Hr Html I IFrame Img Input
    Ins Kbd KeyGen Label Legend Li Link Main Map Mark Menu MenuItem Meta Meter Nav
    NoFrames NoScript Object Ol OptGroup Option Output P Param Pre Progress Q Rp Rt
    Ruby S Samp Script Section Select Small Source Span Strike Strong Style Sub
    Summary Sup Table TBody Td TextArea TFoot Th THead Time Title Tr Track Tt U Ul
    Var Video Wbr
    "

  @[k] = v for k, v of @createDomElementFactories @allElementNames

if module
  module.exports = DomElementFactories
else
  window.DomElementFactories = DomElementFactories
